<html>
<head>
<title>CMU 15-418 (Spring 2012) Final Project Proposal</title>

<link rel="stylesheet" type="text/css" href="style.css">

</head>
<body>

<div class="constrainedWidth">
  
<div style="padding-bottom: 10px;">
<div class="title smallTitle">Project Proposal:</div>
<div class="title" style="width: 900px; padding-bottom: 6px; border-bottom: #000000 2px solid;">
  Parallel simulation of cellular automata
</div>
</div>

<div class="boldText">
<div>Hugues Bruant &lt;<a href="mailto:hugues.bruant@gmail.com">hugues.bruant@gmail.com</a>&gt;</div>
</div>

<div style="padding-top: 1em;"><a href="index.html">Main Project Page</a></div>

<div class="section">Summary</div>
<p>The goal of this project is to implement fast simulation algorithms for cellular
automata on parallel hardware.</p>

<div class="section">Background</div>
<p>Although cellular automata are best known through examples such as Conway's
Game of Life, they have a lot of practical uses in physical modelling. They are
for instance used to simulate lava flow or the deformation of complex surfaces.</p>
<p>In the most common model, the state of all cells change synchronously and the
new state of each cell only depend of the previous state of its neighbors, making
the naive simulation algorithm embarassingly parallel. More elaborate simulation
algorithms allow significant performance improvements but are harder to efficiently
parallelize.</p>

<div class="section">Challenge</div>
<p>Although the naive simulation is embarassingly parallel, it is also embarassingly
inefficient, usually doing a lot of unnecessary work. On the other hand, the more
elaborate algorithms typically rely on data structures that are not designed with
parallelism in mind. Striking the best balance between these two extremes will be
key to achieving high performance.</p>
<p>Cellular automata encompass a very large landscape, from Conway's Game of
Life, in which each cell has two possible states and the transition function is
as simple as counting neighbors, to complicated lava simulation models where
each cell has five scalar values and evolution follows complex numerical equations.
While it would be impossible to support all cases efficiently, the implementation
should strive to accommodate a large variety of CA and simulate each of them as
efficiently as possible.</p>

<div class="section">Resources</div>
<p>All the work will be done from scratch.</p>
<p>I will do most of the prototyping on my laptop, using a venerable GeForce 9500M GS 
(Compute 1.1) and performance testing on the GTX 480 of the Gates cluster.</p>

<div class="section">Goals/Deliverables</div>
<ul>
    <li>Implement one or more CA simulation algorithms using CUDA
    <li>Create some benchmarks that show the strength and weakness of this (these)
    algorithm(s)
    <li><b>[stretch]</b>Implement an FPGA-based variant of these algorithms
    <li><b>[stretch]</b>Come up with a cool (visual) demo
</ul>

<div class="section">Platform</div>
<p>Scientific computing is always eager for more performance and therefore
often on the frontline. It started using distributed computing before it was
cool and pretty much started the whole GPGPU movement.</p>
<p>If I have enough time and manage to get my hands on an FPGA, I would also
like to implement CA simulation on this platform and compare its strength and
weaknesses to that of GPGPU.</p>

<div class="section">Proposed Schedule</div>

<p>
<table class="projectSchedule">
<tr>
  <td width="110"><span style="font-weight: bold;">Week</span></td>
  <td width="380"><span style="font-weight: bold;">What I Plan To Do</span></td>
</tr>
<tr><td>Apr 1-7</td><td>Papers reading, notebook scribbling</td></tr>
<tr><td>Apr 8-14</td><td>More scribbling, initial prototyping</td></tr>
<tr><td>Apr 15-21</td><td>Implementation, tests and benchmarks</td></tr>
<tr><td>Apr 22-28</td><td>Implementation, tests and benchmarks</td></tr>
<tr><td>Apr 29-May 5</td><td>Performance tuning</td></tr>
<tr><td>May 6-11</td><td>Write up results</td></tr>
</table>
</p>

</div>

</body>
</html>
